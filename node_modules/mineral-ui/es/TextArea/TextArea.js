var _jsx = function () { var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; return function createRawReactElement(type, props, key, children) { var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = {}; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2017 CA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { Component } from 'react';
import { canUseDOM } from 'exenv';
import FontFaceObserver from 'fontfaceobserver';
import { createStyledComponent, getNormalizedValue, pxToEm } from '../styles';

export var componentTheme = function componentTheme(baseTheme) {
  return _extends({
    TextArea_backgroundColor: baseTheme.backgroundColor_input,
    TextArea_borderColor: baseTheme.borderColor,
    TextArea_borderColor_active: baseTheme.borderColor,
    TextArea_borderColor_focus: baseTheme.borderColor,
    TextArea_borderColor_hover: baseTheme.borderColor_hover,
    TextArea_borderRadius: baseTheme.borderRadius_1,
    TextArea_borderWidth: '1px',
    TextArea_boxShadow_active: '0 0 0 1px ' + baseTheme.color_white + ', 0 0 0 2px ' + baseTheme.borderColor_active,
    TextArea_boxShadow_focus: '0 0 0 1px ' + baseTheme.color_white + ', 0 0 0 2px ' + baseTheme.borderColor_focus,
    TextArea_color_text: baseTheme.color_gray_80,
    TextArea_color_placeholder: baseTheme.color_gray_60,
    TextArea_fontSize: baseTheme.fontSize_ui,
    TextArea_fontSize_small: pxToEm(12),
    TextArea_paddingHorizontal: baseTheme.space_inset_md,
    // The following padding values make appearances equivalent to TextInputs of same size when rows=1.
    // This enables usage of a TextArea as a single line input that can accept multiple lines of text.
    TextArea_paddingVertical_jumbo: pxToEm(14.5),
    TextArea_paddingVertical_large: pxToEm(8.5),
    TextArea_paddingVertical_medium: pxToEm(4.5),
    TextArea_paddingVertical_small: pxToEm(2)

  }, baseTheme);
};

var styles = {
  textArea: function textArea(_ref) {
    var disabled = _ref.disabled,
        readOnly = _ref.readOnly,
        resizeable = _ref.resizeable,
        size = _ref.size,
        baseTheme = _ref.theme,
        variant = _ref.variant;

    var theme = componentTheme(baseTheme);
    if (variant) {
      // prettier-ignore
      theme = _extends({}, theme, {
        TextArea_borderColor_hover: theme['borderColor_' + variant + '_hover'],
        TextArea_boxShadow_active: '0 0 0 1px ' + theme.color_white + ', 0 0 0 2px ' + theme['borderColor_' + variant],
        TextArea_boxShadow_focus: '0 0 0 1px ' + theme.color_white + ', 0 0 0 2px ' + theme['borderColor_' + variant]
      });
    }

    var fontSize = size === 'small' ? theme.TextArea_fontSize_small : theme.TextArea_fontSize;
    var paddingVerticalNormalized = getNormalizedValue(theme['TextArea_paddingVertical_' + size], fontSize);
    var placeholderStyles = {
      color: theme.TextArea_color_placeholder,
      fontStyle: 'italic'
    };

    return {
      backgroundColor: 'transparent',
      border: 0,
      boxShadow: 'none',
      color: disabled ? theme.color_text_disabled : theme.TextArea_color_text,
      flex: '1 1 auto',
      fontFamily: 'inherit',
      fontSize: fontSize,
      lineHeight: theme.lineHeight_prose,
      margin: theme.TextArea_borderWidth,
      // minHeight value is an attempt to display a single line of text.
      // It is needed when a user manually resizes a textarea.
      minHeight: parseFloat(paddingVerticalNormalized) * 2 + parseFloat(theme.TextArea_fontSize) * theme.lineHeight + parseFloat(pxToEm(parseFloat(theme.TextArea_borderWidth) * 2)) + parseFloat(pxToEm(2)) + 'em',
      minWidth: 0,
      outline: 0,
      padding: paddingVerticalNormalized + ' ' + getNormalizedValue(theme.TextArea_paddingHorizontal, fontSize),
      resize: resizeable ? 'vertical' : 'none',
      width: '100%',

      '&::placeholder': placeholderStyles,
      '&::-ms-input-placeholder': placeholderStyles, // Edge
      '&:-ms-input-placeholder': placeholderStyles, // IE 11

      '&::-ms-clear': {
        display: 'none'
      },

      '&:hover,&[data-simulate-hover]': {
        '& ~ div': {
          borderColor: !disabled ? theme.TextArea_borderColor_hover : null
        }
      },

      '&:focus,&[data-simulate-focus]': {
        '& ~ div': {
          borderColor: theme.TextArea_borderColor_focus,
          boxShadow: theme.TextArea_boxShadow_focus
        }
      },

      '&:active,&[data-simulate-active]': {
        '& ~ div': {
          borderColor: theme.TextArea_borderColor_active,
          boxShadow: disabled ? 'none' : theme.TextArea_boxShadow_active
        }
      },

      '& ~ div': {
        backgroundColor: disabled || readOnly ? theme.backgroundColor_disabled : theme.TextArea_backgroundColor,
        borderColor: variant && !disabled && !readOnly ? theme['borderColor_' + variant] : theme.TextArea_borderColor,
        borderRadius: theme.TextArea_borderRadius,
        borderStyle: 'solid',
        borderWidth: theme.TextArea_borderWidth,
        bottom: 0,
        left: 0,
        position: 'absolute',
        right: 0,
        top: 0,
        zIndex: -1
      }
    };
  },
  root: {
    alignItems: 'center',
    cursor: 'text',
    display: 'flex',
    position: 'relative',
    width: '100%'
  }
};

var Root = createStyledComponent('div', styles.root, {
  displayName: 'TextArea',
  includeStyleReset: true
});
var _TextArea = createStyledComponent('textarea', styles.textArea, {
  rootEl: 'textarea'
});

var sizeToRows = {
  small: 2,
  medium: 6,
  large: 8,
  jumbo: 12
};

/**
 * TextArea allows your app to accept a potentially lengthy text value from the
 * user.
 */

var _ref3 = _jsx('div', {});

var TextArea = function (_Component) {
  _inherits(TextArea, _Component);

  function TextArea() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, TextArea);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = TextArea.__proto__ || Object.getPrototypeOf(TextArea)).call.apply(_ref2, [this].concat(args))), _this), _this.handleInput = function (event) {
      var _this$props = _this.props,
          autoSize = _this$props.autoSize,
          onInput = _this$props.onInput;


      autoSize && _this.autoSize();

      onInput && onInput(event);
    }, _this.autoSize = function () {
      var autoSize = _this.props.autoSize;

      if (!autoSize || !_this.textArea || !canUseDOM) {
        return;
      }

      var _window$getComputedSt = window.getComputedStyle(_this.textArea),
          maxHeight = _window$getComputedSt.maxHeight,
          minHeight = _window$getComputedSt.minHeight;

      /** $FlowFixMe */


      _this.textArea.style.height = 'auto';
      /** $FlowFixMe */
      _this.textArea.style.overflowY = 'hidden';
      /** $FlowFixMe */
      _this.textArea.style.height = Math.max(parseFloat(minHeight), Math.min(
      /** $FlowFixMe */
      parseFloat(_this.textArea.scrollHeight), parseFloat(maxHeight) || window.Infinity)) + 'px';
    }, _this.removeAutoSize = function () {
      if (_this.textArea) {
        _this.textArea.style.height = '';
        _this.textArea.style.overflowY = '';
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(TextArea, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.autoSize();

      // Auto sized height can sometimes be slightly incorrect before web font has
      // loaded due differences in font metrics.  Here we call it again after the
      // fontFamily has loaded.
      if (this.textArea && canUseDOM) {
        var fontFamily = window.getComputedStyle(this.textArea).fontFamily.replace(/["']/g, '').split(',')[0];
        var font = new FontFaceObserver(fontFamily);
        font.load().then(this.autoSize, function () {});
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props = this.props,
          autoSize = _props.autoSize,
          rows = _props.rows,
          size = _props.size,
          value = _props.value;
      var prevAutoSize = prevProps.autoSize,
          prevRows = prevProps.rows,
          prevSize = prevProps.size,
          prevValue = prevProps.value;


      if (autoSize && (!prevAutoSize || value !== prevValue || rows !== prevRows || size !== prevSize)) {
        this.autoSize();
      }

      if (!autoSize && prevAutoSize) {
        this.removeAutoSize();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props2 = this.props,
          autoSize = _props2.autoSize,
          className = _props2.className,
          disabled = _props2.disabled,
          inputRef = _props2.inputRef,
          invalid = _props2.invalid,
          readOnly = _props2.readOnly,
          required = _props2.required,
          _props2$resizeable = _props2.resizeable,
          resizeable = _props2$resizeable === undefined ? true : _props2$resizeable,
          otherRootProps = _props2.rootProps,
          rows = _props2.rows,
          _props2$size = _props2.size,
          size = _props2$size === undefined ? 'large' : _props2$size,
          variant = _props2.variant,
          restProps = _objectWithoutProperties(_props2, ['autoSize', 'className', 'disabled', 'inputRef', 'invalid', 'readOnly', 'required', 'resizeable', 'rootProps', 'rows', 'size', 'variant']);

      var rootProps = _extends({
        className: className,
        variant: variant
      }, otherRootProps);

      var textAreaProps = _extends({
        'aria-invalid': invalid,
        'aria-required': required,
        autoSize: autoSize,
        disabled: disabled,
        innerRef: function innerRef(ref) {
          _this2.textArea = ref;
          if (inputRef) {
            inputRef(ref);
          }
        },
        onInput: this.handleInput,
        readOnly: readOnly,
        required: required,
        resizeable: autoSize ? false : resizeable,
        rows: rows || size && sizeToRows[size] || undefined,
        size: size,
        variant: variant
      }, restProps);

      return React.createElement(
        Root,
        rootProps,
        React.createElement(_TextArea, textAreaProps),
        _ref3
      );
    }
  }]);

  return TextArea;
}(Component);

TextArea.propTypes = {
  /** Automatically adjust the height of the input to fit the content */
  autoSize: require('prop-types').bool,

  /** @Private CSS className */
  className: require('prop-types').string,

  /** Initial value of the input. Primarily for use with uncontrolled components */
  defaultValue: require('prop-types').string,

  /** Disables the input */
  disabled: require('prop-types').bool,

  /** ref for the input */
  inputRef: require('prop-types').func,

  /** Props to be applied directly to the root element, rather than the input */
  rootProps: require('prop-types').object,

  /** Indicates that the value of the element is invalid */
  invalid: require('prop-types').bool,

  /** @Private Used internally in conjunction with autoSize prop. Must also support a custom function. */
  onInput: require('prop-types').func,

  /** Function called when input value changes */
  onChange: require('prop-types').func,

  /** Indicates that the user cannot modify the value of the input */
  readOnly: require('prop-types').bool,

  /** Indicates that the user must fill in a value before submitting a form */
  required: require('prop-types').bool,

  /** Indicates whether input is resizable. _Not currently supported in IE/Edge._ */
  resizeable: require('prop-types').bool,

  /** The number of visible text lines in the input */
  rows: require('prop-types').number,

  /** Available sizes */
  size: require('prop-types').oneOf(['small', 'medium', 'large', 'jumbo']),

  /** The initial value of the input. Primarily for use with controlled components.  If this prop is specified, an onChange handler must also be specified.  Also see `defaultValue`. */
  value: require('prop-types').string,

  /** Available variants */
  variant: require('prop-types').oneOf(['success', 'warning', 'danger'])
};
export default TextArea;