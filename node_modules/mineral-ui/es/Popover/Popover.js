var _jsx = function () { var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; return function createRawReactElement(type, props, key, children) { var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = {}; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2017 CA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { Children, cloneElement, Component } from 'react';
import { findDOMNode } from 'react-dom';
import { Manager } from 'react-popper';
import { createStyledComponent } from '../styles';
import { generateId, composeEventHandlers } from '../utils';
import EventListener from '../EventListener';
import Portal from '../Portal';
import PopoverTrigger from './PopoverTrigger';
import PopoverContent, { componentTheme as popoverContentComponentTheme } from './PopoverContent';
import { componentTheme as popoverArrowComponentTheme } from './PopoverArrow';

export var componentTheme = function componentTheme(baseTheme) {
  return _extends({}, popoverArrowComponentTheme(baseTheme), popoverContentComponentTheme(baseTheme), baseTheme);
};

var Root = createStyledComponent(Manager, {
  display: 'inline-block'
}, {
  displayName: 'Popover',
  forwardProps: ['tag']
});

/**
 * Popovers float over page content and hold supporting information or user controls.
 */

var Popover = function (_Component) {
  _inherits(Popover, _Component);

  function Popover() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Popover);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Popover.__proto__ || Object.getPrototypeOf(Popover)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      isOpen: Boolean(_this.props.defaultIsOpen)
    }, _this.id = 'popover-' + generateId(), _this.close = function (event) {
      if (_this.isControlled()) {
        _this.closeActions(event);
      } else {
        _this.setState(function () {
          return { isOpen: false };
        }, function () {
          _this.closeActions(event);
        });
      }
    }, _this.closeActions = function (event) {
      var _this$props = _this.props,
          focusTriggerOnClose = _this$props.focusTriggerOnClose,
          onClose = _this$props.onClose;

      onClose && onClose(event);

      var _ref2 = _this.isControlled() ? _this.props : _this.state,
          isOpen = _ref2.isOpen;

      !isOpen && focusTriggerOnClose && _this.focusTrigger();
    }, _this.focusTrigger = function () {
      var node = findDOMNode(_this.popoverTrigger); // eslint-disable-line react/no-find-dom-node
      if (node && node.firstChild && node.firstChild instanceof HTMLElement) {
        node.firstChild.focus();
      }
    }, _this.handleDocumentClick = function (event) {
      if (_this.isClickOutsideComponent(event)) {
        _this.close(event);
      }
    }, _this.handleDocumentKeydown = function (event) {
      if (event.key === 'Escape') {
        _this.close(event);
      }
    }, _this.isClickOutsideComponent = function (event) {
      /* eslint-disable react/no-find-dom-node */
      var usePortal = _this.props.usePortal;

      var node = findDOMNode(_this);
      var popoverContentNode = findDOMNode(_this.popoverContent);

      if (usePortal) {
        return node && node instanceof HTMLElement && event.target && event.target instanceof HTMLElement && !node.contains(event.target) && popoverContentNode && popoverContentNode instanceof HTMLElement && !popoverContentNode.contains(event.target);
      } else {
        return node && node instanceof HTMLElement && event.target && event.target instanceof HTMLElement && !node.contains(event.target);
      }
    }, _this.isControlled = function () {
      return _this.props.isOpen !== undefined;
    }, _this.open = function (event) {
      if (_this.isControlled()) {
        _this.openActions(event);
      } else {
        _this.setState(function () {
          return { isOpen: true };
        }, function () {
          _this.openActions(event);
        });
      }
    }, _this.openActions = function (event) {
      _this.focusTrigger();
      _this.props.onOpen && _this.props.onOpen(event);
    }, _this.toggleOpenState = function (event) {
      var _ref3 = _this.isControlled() ? _this.props : _this.state,
          isOpen = _ref3.isOpen;

      if (isOpen) {
        _this.close(event);
      } else {
        _this.open(event);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Popover, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          children = _props.children,
          content = _props.content,
          disabled = _props.disabled,
          getContentProps = _props.getContentProps,
          getTriggerProps = _props.getTriggerProps,
          hasArrow = _props.hasArrow,
          modifiers = _props.modifiers,
          placement = _props.placement,
          subtitle = _props.subtitle,
          title = _props.title,
          triggerRef = _props.triggerRef,
          usePortal = _props.usePortal,
          wrapContent = _props.wrapContent,
          restProps = _objectWithoutProperties(_props, ['children', 'content', 'disabled', 'getContentProps', 'getTriggerProps', 'hasArrow', 'modifiers', 'placement', 'subtitle', 'title', 'triggerRef', 'usePortal', 'wrapContent']);

      var _ref4 = this.isControlled() ? this.props : this.state,
          isOpen = _ref4.isOpen;

      var rootProps = _extends({}, restProps, {
        tag: false
      });
      var contentId = this.id + '-popoverContent';

      var child = Children.only(children);

      var popoverTriggerProps = {
        contentId: contentId,
        children: child,
        disabled: disabled,
        isOpen: Boolean(isOpen),
        onClick: !disabled ? composeEventHandlers(this.toggleOpenState, child.props.onClick) : undefined,
        ref: function ref(node) {
          _this2.popoverTrigger = node;
          triggerRef && triggerRef(node);
        }
      };

      popoverTriggerProps = _extends({}, popoverTriggerProps, getTriggerProps && getTriggerProps(popoverTriggerProps));

      var popoverContent = void 0;
      if (isOpen) {
        if (wrapContent) {
          var popoverContentProps = {
            hasArrow: hasArrow,
            id: contentId,
            modifiers: modifiers,
            placement: placement,
            ref: function ref(node) {
              _this2.popoverContent = node;
            },
            subtitle: subtitle,
            tabIndex: 0,
            title: title
          };

          popoverContentProps = _extends({}, popoverContentProps, getContentProps && getContentProps(popoverContentProps));

          popoverContent = React.createElement(
            PopoverContent,
            popoverContentProps,
            content
          );
        } else {
          popoverContent = cloneElement(content, {
            ref: function ref(node) {
              _this2.popoverContent = node;
            }
          });
        }

        if (usePortal) {
          popoverContent = _jsx(Portal, {}, void 0, popoverContent);
        }
      }

      return React.createElement(
        Root,
        rootProps,
        React.createElement(PopoverTrigger, popoverTriggerProps),
        isOpen && popoverContent,
        isOpen && _jsx(EventListener, {
          listeners: [{
            target: 'document',
            event: 'click',
            handler: this.handleDocumentClick,
            options: true
          }, {
            target: 'document',
            event: 'keydown',
            handler: this.handleDocumentKeydown,
            options: true
          }]
        })
      );
    }
  }]);

  return Popover;
}(Component);

Popover.propTypes = {
  /** Trigger for the Popover */
  children: typeof React$Node === 'function' ? require('prop-types').instanceOf(React$Node).isRequired : require('prop-types').any.isRequired,

  /** Content of the Popover */
  content: typeof $FlowFixMe === 'function' ? require('prop-types').instanceOf($FlowFixMe).isRequired : require('prop-types').any.isRequired,

  /** For use with uncontrolled components, in which the Popover is immediately open upon initialization */
  defaultIsOpen: require('prop-types').bool,

  /** Disables the Popover */
  disabled: require('prop-types').bool,

  /**
   * Determines whether focus will be set to the trigger when the Popover is
   * closed.
   */
  focusTriggerOnClose: require('prop-types').bool,

  /** Include an arrow on the Popover content pointing to the trigger */
  hasArrow: require('prop-types').bool,

  /** For use with controlled components, in which the app manages Popover state */
  isOpen: require('prop-types').bool,

  /**
   * Plugins that are used to alter behavior. See
   * [PopperJS docs](https://popper.js.org/popper-documentation.html#modifiers)
   * for options.
   */
  modifiers: require('prop-types').object,

  /** Called when Popover is closed */
  onClose: require('prop-types').func,

  /** Called when Popover is opened */
  onOpen: require('prop-types').func,

  /** Function that returns props to be applied to the PopoverContent */
  getContentProps: require('prop-types').func,

  /** Function that returns props to be applied to the trigger */
  getTriggerProps: require('prop-types').func,

  /** Placement of the Popover */
  placement: require('prop-types').oneOf(['auto', 'auto-end', 'auto-start', 'bottom', 'bottom-end', 'bottom-start', 'left', 'left-end', 'left-start', 'right', 'right-end', 'right-start', 'top', 'top-end', 'top-start']),

  /** Subtitle displayed under the title */
  subtitle: typeof React$Node === 'function' ? require('prop-types').instanceOf(React$Node) : require('prop-types').any,

  /** Title of the Popover */
  title: typeof React$Node === 'function' ? require('prop-types').instanceOf(React$Node) : require('prop-types').any,

  /** @Private ref for the Popover trigger */
  triggerRef: require('prop-types').func,

  /** Use a Portal to render the Popover to the body rather than as a sibling to the trigger */
  usePortal: require('prop-types').bool,

  /** Display the content with default styles */
  wrapContent: require('prop-types').bool
};
Popover.defaultProps = {
  focusTriggerOnClose: true,
  hasArrow: true,
  placement: 'bottom',
  wrapContent: true
};
export default Popover;