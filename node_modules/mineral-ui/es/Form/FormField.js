var _jsx = function () { var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; return function createRawReactElement(type, props, key, children) { var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = {}; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2017 CA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { Children, cloneElement, createElement, Component } from 'react';

import { createStyledComponent, getNormalizedValue } from '../styles';
import { generateId } from '../utils';

var REGEX_GROUP = /(Checkbox|Radio|Group)/i;

export var componentTheme = function componentTheme(baseTheme) {
  return _extends({
    FormFieldCaption_color_text: baseTheme.color_gray_80,
    FormFieldCaption_fontSize: baseTheme.fontSize_mouse,
    FormFieldCaption_marginTop: baseTheme.space_stack_xxs,
    FormFieldCaption_marginTop_isGroup: baseTheme.space_stack_sm,

    FormFieldLabel_color_text: baseTheme.color_gray_80,
    FormFieldLabel_fontSize: baseTheme.fontSize_ui,
    FormFieldLabel_fontWeight: baseTheme.fontWeight_semiBold,
    FormFieldLabel_marginBottom: baseTheme.space_stack_sm,

    FormFieldSecondaryText_fontSize: baseTheme.fontSize_mouse,
    FormFieldSecondaryText_color_text: baseTheme.color_gray_80,
    FormFieldSecondaryText_color_text_required: baseTheme.color_text_danger

  }, baseTheme);
};

var styles = {
  caption: function caption(_ref) {
    var isGroup = _ref.isGroup,
        baseTheme = _ref.theme,
        variant = _ref.variant;

    var theme = componentTheme(baseTheme);
    if (variant) {
      // prettier-ignore
      theme = _extends({}, theme, {
        FormFieldCaption_color_text: baseTheme['color_text_' + variant]
      });
    }

    var fontSize = theme.FormFieldCaption_fontSize;

    return {
      color: theme.FormFieldCaption_color_text,
      fontSize: fontSize,
      marginTop: isGroup ? getNormalizedValue(theme.FormFieldCaption_marginTop_isGroup, fontSize) : getNormalizedValue(theme.FormFieldCaption_marginTop, fontSize)
    };
  },
  textWrapper: function textWrapper(_ref2) {
    var hideLabel = _ref2.hideLabel,
        baseTheme = _ref2.theme;

    var theme = componentTheme(baseTheme);

    return _extends({
      color: theme.FormFieldLabel_color_text,
      display: 'flex',
      fontSize: theme.FormFieldLabel_fontSize,
      fontWeight: theme.FormFieldLabel_fontWeight,
      justifyContent: 'space-between',
      marginBottom: theme.FormFieldLabel_marginBottom
    }, hideLabel ? {
      border: '0',
      clip: 'rect(0 0 0 0)',
      clipPath: 'inset(50%)',
      height: '1px',
      margin: '-1px',
      overflow: 'hidden',
      padding: '0',
      position: 'absolute',
      whiteSpace: 'nowrap',
      width: '1px'
    } : {}, {
      '& > *': {
        alignSelf: 'flex-end',
        display: 'inline-block'
      }
    });
  },
  secondaryText: function (_secondaryText) {
    function secondaryText(_x) {
      return _secondaryText.apply(this, arguments);
    }

    secondaryText.toString = function () {
      return _secondaryText.toString();
    };

    return secondaryText;
  }(function (_ref3) {
    var secondaryText = _ref3.secondaryText,
        baseTheme = _ref3.theme;

    var theme = componentTheme(baseTheme);

    return {
      color: secondaryText ? theme.FormFieldSecondaryText_color_text : theme.FormFieldSecondaryText_color_text_required,
      fontSize: theme.FormFieldSecondaryText_fontSize
    };
  })
};

var Root = createStyledComponent('div', {}, {
  displayName: 'FormField',
  includeStyleReset: true
});
var TextWrapper = createStyledComponent('div', styles.textWrapper);
var SecondaryText = createStyledComponent('span', styles.secondaryText);
var Caption = createStyledComponent('div', styles.caption);

/**
 * The FormField component enhances form inputs with an accessible label and
 * optionally displays additional help text.
 */

var FormField = function (_Component) {
  _inherits(FormField, _Component);

  function FormField() {
    var _ref4;

    var _temp, _this, _ret;

    _classCallCheck(this, FormField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref4 = FormField.__proto__ || Object.getPrototypeOf(FormField)).call.apply(_ref4, [this].concat(args))), _this), _this.id = 'formField-' + generateId(), _this.getControlName = function () {
      var _this$props = _this.props,
          children = _this$props.children,
          input = _this$props.input;

      var controlName = void 0;

      if (input && input.name) {
        controlName = input.name;
      } else if (children) {
        var child = Children.only(children);
        if (child.type && child.type.name) {
          controlName = child.type.name;
        }
      }

      return controlName;
    }, _this.isGroup = function () {
      var controlName = _this.getControlName();

      return controlName && REGEX_GROUP.test(controlName);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(FormField, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          caption = _props.caption,
          children = _props.children,
          className = _props.className,
          hideLabel = _props.hideLabel,
          input = _props.input,
          label = _props.label,
          required = _props.required,
          requiredText = _props.requiredText,
          otherRootProps = _props.rootProps,
          secondaryText = _props.secondaryText,
          variant = _props.variant,
          restProps = _objectWithoutProperties(_props, ['caption', 'children', 'className', 'hideLabel', 'input', 'label', 'required', 'requiredText', 'rootProps', 'secondaryText', 'variant']);

      var rootProps = _extends({
        className: className
      }, otherRootProps);

      // Label structure differs if input/control is a grouped control which has
      // its own label tag.  e.g. Radio, Checkbox, RadioGroup, CheckboxGroup
      var isGroup = this.isGroup();
      var Label = isGroup ? 'div' : 'label';

      var textWrapperProps = {
        hideLabel: hideLabel,
        key: this.id + '-textWrapper'
      };

      var labelTextProps = {
        id: this.id + '-labelText'
      };

      var captionProps = {
        caption: caption,
        isGroup: isGroup,
        variant: variant,
        id: this.id + '-caption'
      };

      var controlProps = function controlProps() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        return _extends({
          'aria-describedby': caption && captionProps.id,
          key: _this2.id + '-control',
          required: required,
          rootProps: isGroup ? _extends({
            'aria-labelledby': labelTextProps.id,
            'aria-describedby': caption && captionProps.id
          }, props.rootProps) : props.rootProps,
          variant: variant
        }, restProps);
      };

      var control = null;
      if (input) {
        control = createElement(input, controlProps());
      } else if (children) {
        var child = Children.only(children);
        control = cloneElement(child, controlProps(child.props));
      }

      return React.createElement(
        Root,
        rootProps,
        _jsx(Label, {}, void 0, React.createElement(
          TextWrapper,
          textWrapperProps,
          React.createElement(
            'span',
            labelTextProps,
            label
          ),
          (required || secondaryText) && _jsx(SecondaryText, {
            secondaryText: secondaryText
          }, void 0, secondaryText ? secondaryText : requiredText)
        ), control),
        caption && React.createElement(
          Caption,
          captionProps,
          caption
        )
      );
    }
  }]);

  return FormField;
}(Component);

FormField.propTypes = {
  /**
   * Caption associated with the input element; commonly used to provide help
   * text
   */
  caption: require('prop-types').oneOfType([require('prop-types').string, typeof React$Element === 'function' ? require('prop-types').instanceOf(React$Element) : require('prop-types').any]),

  /** Form input element */
  children: typeof React$Node === 'function' ? require('prop-types').instanceOf(React$Node) : require('prop-types').any,

  /** @Private CSS className */
  className: require('prop-types').string,

  /** Visually hide label, but keep available for assistive technologies */
  hideLabel: require('prop-types').bool,

  /** Form input class; alternative to `children` */
  input: typeof React$ComponentType === 'function' ? require('prop-types').instanceOf(React$ComponentType) : require('prop-types').any,

  /** Props to be applied directly to the root element, rather than the input */
  rootProps: require('prop-types').object,

  /** Label associated with the input element */
  label: require('prop-types').oneOfType([require('prop-types').string, typeof React$Element === 'function' ? require('prop-types').instanceOf(React$Element) : require('prop-types').any]).isRequired,

  /** Marks associated input as required */
  required: require('prop-types').bool,

  /** Text used to indicate a required field */
  requiredText: require('prop-types').oneOfType([require('prop-types').string, typeof React$Element === 'function' ? require('prop-types').instanceOf(React$Element) : require('prop-types').any]),

  /**
   * Secondary text associated with the input element; takes precedence over
   * `requiredText`
   */
  secondaryText: require('prop-types').oneOfType([require('prop-types').string, typeof React$Element === 'function' ? require('prop-types').instanceOf(React$Element) : require('prop-types').any]),

  /** Available variants */
  variant: require('prop-types').oneOf(['success', 'warning', 'danger'])
};
FormField.defaultProps = {
  requiredText: 'Required'
};
export default FormField;